# koishi-plugin-word-core

[![npm](https://img.shields.io/npm/v/koishi-plugin-word-core?style=flat-square)](https://www.npmjs.com/package/koishi-plugin-word-core)


> 词库引擎
>
> 小型文字游戏引擎/对话插件

# 快速使用

## 简介

`word-core`是一款设置对话的插件，类似于`dialogue`插件，可以通过设置`触发词`以及`回答`来让机器人与你对话

你编写的问答会存储在`库`中，默认为`default`库，当你进入一个`不存在的库`并且`编辑`它的时候，会自动新建一个库，库作者是你自己

每个`库`都有作者，非作者无法修改库的内容，库的作者可以添加`别的用户`为`词库作者`而进行一起编写

你设定的`触发词`可以拥有`多个回答`，当你触发触发词的时候，会从回答中`随机输出一条回答`

在你添加或删除问答的时候，默认会被添加或删除到 `default`这个 `词库`，你可以通过指令修改你想要编辑的词库

另外在本文档中，<>代表的是可不填选项，[]代表的是必填选项

## 修改编辑的库

> 格式：word.setedit <库名>
>
> 例子：word.setedit 测试
>
> 例子：word.setedit

修改你正在编辑的库，如果不写后面的库名，则代表恢复到编辑 `default`默认库

## 添加问答

> 格式：word.add [触发词] [回复]
>
> 例子：word.add 你好 你也好哦~

一个触发词可以拥有多个回答，每个回答会有自己的 `序号`，每次触发时随机回复一个回答

## 删除问答

> 格式：word.rm [触发词] [序号]
>
> 例子：word.rm 你好 1

使用序号删除回答

# 进阶使用

## 设置权限

须知：

词库编辑需要拥有词库的编辑权限：word.edit.[词库名]

词库管理员或者拥有word.admin.add/rm可以修改别人的权限（词库管理员则需要将自己的id填写在插件配置处）

这里所用的id是指koishi的 `session.uid`

### 查看自己的id

> 格式：word.id

### 添加权限

> 格式：word.addp [用户id] [权限节点]
>
> 例子：word.addp 6503fb7b50308 word.edit.*

### 删除权限

> 格式：word.rmp [用户id] [权限节点]
>
> 例子：word.rmp 6503fb7b50308 word.edit.*

## 编写词库

在一开始的快速入门处，词库核心还做了一些其他的事情。在这个章节我们需要了解它。

---

每个词库都有作者，所以每个词库都有 `作者`属性，词库可能会产生数据，所以每个词库都有自己的 `存储格`属性。

### 作者属性

这个属性是一个数组，当你创建一个词库的时候，词库会将你设置为数组内的一员。作者可以添加或删除其他人为本词库的作者。非作者无法修改词库，即使你拥有此词库的修改权限。

> 添加作者
>
> 格式：word.addauthor [新作者uid]
>
> 例子：word.addauthor 6503fb7b50308

> 取消作者
>
> 格式：word.rmauthor [需要删除的作者id]
>
> 例子：word.rmauthor 6503fb7b50308

### 存储格

这个属性是一个字符串，这意味着，每个词库只能设置一个存储格。本词库的词库语句产生的数据，会添加到此存储格。它默认为”default“。多个词库设置的存储格为同一个的时候，意味着这些词库的物品是 `通用`的。

> 设置存储格
>
> 格式：word.setsave [存储格]
>
> 例子：word.setsave 存储1

> 恢复到默认存储格
>
> 格式：word.resetsave

> 查看当前词库的存储格子是哪个
>
> 格式：word.getsave

### 寻找某个触发句在哪个词库

> 格式：word.find [触发句]
>
> 例子：word.find 你好

### 查看当前词库某触发句的所有回答

> 格式：word.get [触发句]
>
> 例子：word.get 你好

# 开发简介

## 基础介绍

词库核心是一个对话插件，但是它在基础的对话插件的基础上，增加了一些东西：

![截图](http://r.iirose.com/i/23/11/30/11/0932-LV.png)

当对话的回复内包含 `(aaa:xxxx:xx...)`的词库 `语法结构`的时候，会 `由内而外，由前到后`地将每个 `语法结构`解析，然后去调用词库核心的 `规则包`

规则包就像这个：

```javascript
statementexport const statement: statementType = {
  '+': async (inData: chatFunctionType, ctx: Context): Promise<string | void> => {
    return inData.args[1];
  }
};

// inData内包含
// args: string[] 此属性的值是当前(aaa:xxx:xxxxx:xx...)词库语法结构的第一个":"后的内容，分割成的数组：[xxx,xxxxx,xx....]
// matchs：在问问题时的匹配到的值（后续章节会详细说明）
```

规则包内的函数的返回值会替换掉语法结构！

大胆设想：

我们可以设计一些规则包来做出以下的效果！

> 问：钓鱼
>
> 答：你钓到了(+:鱼:1:100)条鱼

> 问：查看我的鱼娄
>
> 答：你拥有(#:鱼)条鱼

这么建议的搭建一个钓鱼小游戏~

## 可扩展词库语法规则

词库核心将：

* 用户管理
* 权限管理
* 编辑词库
* 语法包

等内容都封装到了word服务，上面说明的statement规则可以使用：

* ctx.word.addStatement
* ctx.word.rmStatement

进行添加

## 提问正则替换

在问答时我们不免需要遇到一些情况，比如查询天气

问：查询xxx的天气

通过设置固定的问答可能并不能匹配这样的情况，于是我在问题匹配处设置了 `允许匹配正则`，并且将正则匹配到的内容，送入 `规则包的inData属性下的matchs`，比如如下的情况

> 需要获取输入的数字并且在回答中显示：
>
> 设定这样的问答：
>
> 问：我输入的第一个数(数)，输入的第二个数(数)
>
> 答：(输入数:1)，(输入数:2)

> 有人这么触发了：
>
> 我输入的数111，输入的数222

```javascript
// 定义一个输入trigger：
ctx.word.addTrigger('inputNumber', '(数)', '[\d]+?');
// 定义一个语法包
ctx.word.addStatement('输入数', (inData, ctx)=>{
  // 获取(输入数字:xx)的xx
  const inputNumber1 = inData.args[0];
  // 此时的inData.matchs的内容是：
  // {
  //  inputNumber: [111,222]
  // }
  return inData.matchs[inputNumber1];
})
```

# 反馈&回复

请在评论区告诉我大概看不懂的地方，我会进行修改

# 正在制作

* [ ] 完善开发文档，包括word的各个api
* [x] 编写词库规则：`添加物品到背包`
* [x] 编写词库规则：`从背包减少物品`
* [x] 编写词库规则：`根据物品数量回复不同的话`
* [x] 编写词库规则：`延迟显示`
* [x] 编写词库规则：`添加物品到他人背包`
* [x] 编写词库规则：`减少物品从他人背包`
* [x] 编写词库规则：`根据他人物品数量不同回复不同的话`
* [ ] 编写词库规则：`词库商城`
* [ ] 编写词库规则：`未完待续`
